package com.srikanth.glassstream.svc;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.graphics.SurfaceTexture;
import android.graphics.YuvImage;
import android.hardware.Camera;
import android.net.wifi.WifiManager;
import android.os.IBinder;
import android.os.PowerManager;
import android.util.Log;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class StreamService extends Service {
    private static final String TAG = "StreamService";
    private SurfaceTexture surfaceTexture;
    private int frameCount = 0;
    private int previewW = 640, previewH = 480; // overwritten after HAL confirmation
    private byte[] lastFrameNV21;


    private static final int PORT = 8080;
    private static final int NOTIF_ID = 42;

    // Presets
    public static final int PRESET_LOW_43   = 0; // 480x640 (≤ half-area of ~1.3MP 4:3)
    public static final int PRESET_HIGH_43  = 1; // 1008x1346 (≈4:3 high on EE2)
    public static final int PRESET_LOW_169  = 2; // ≤ half-area of 1080p (typically 720x1280)
    public static final int PRESET_HIGH_169 = 3; // 1080x1920 (portrait)
    public static final int PRESET_VGA_43   = 4; // 640x480 (classic VGA)

    // Configurable at runtime via Intent extras
    private volatile int preset = PRESET_VGA_43;    // default preset
    private volatile boolean enableBuffering = true; // tear-free double-buffer enabled by default

    private PowerManager.WakeLock cpuLock;
    private WifiManager.WifiLock wifiLock;
    private Camera camera;

    private final Object frameLock = new Object();
    private volatile boolean running = false;

    // Double-buffer fields (when enableBuffering == true)
    private byte[] frameReady;   // last completed frame snapshot (published under lock)
    private byte[] frameWrite;   // write target inside the camera callback
    private byte[] snapBuffer;   // encoder's private snapshot copy

    private ServerSocket serverSocket;
    private ExecutorService pool;

    // Per-thread reusable JPEG buffer to reduce allocations
    private final ThreadLocal<ByteArrayOutputStream> jpgPool =
            new ThreadLocal<ByteArrayOutputStream>() {
                @Override protected ByteArrayOutputStream initialValue() {
                    // 1 MB initial; grows automatically if needed
                    return new ByteArrayOutputStream(1 << 20);
                }
            };

    // ---------- Lifecycle ----------

    private void releaseLocks() {
        try { if (wifiLock != null && wifiLock.isHeld()) wifiLock.release(); } catch (Exception ignored) {}
        try { if (cpuLock  != null && cpuLock.isHeld())  cpuLock.release(); }  catch (Exception ignored) {}
    }

    // Choose exact or closest size by |Δw|+|Δh|, accepts either orientation
    private static Camera.Size pickExactOrClosest(Camera.Parameters p, int tw, int th) {
        Camera.Size closest = null;
        int bestScore = Integer.MAX_VALUE;
        for (Camera.Size s : p.getSupportedPreviewSizes()) {
            if ((s.width == tw && s.height == th) || (s.width == th && s.height == tw)) {
                return s;
            }
            int score = Math.abs(s.width - tw) + Math.abs(s.height - th);
            if (score < bestScore) { bestScore = score; closest = s; }
        }
        return closest;
    }

    // 1.5% aspect tolerance (ppm = 15000), safe for Java 6
    private static boolean isAspectApprox(int w, int h, int num, int den) {
        int W = Math.max(w, h), H = Math.min(w, h);
        long lhs = (long) W * den;
        long rhs = (long) H * num;
        long diff = Math.abs(lhs - rhs);
        long base = Math.max(Math.abs(lhs), Math.abs(rhs));
        return diff * 1000000L <= base * 15000L;
    }

    // Largest size with target aspect and area <= maxArea; if none under, largest with aspect
    private static Camera.Size largestAspectUnderArea(Camera.Parameters p, int num, int den, int maxArea) {
        Camera.Size bestUnder = null;
        Camera.Size bestAny   = null;
        for (Camera.Size s : p.getSupportedPreviewSizes()) {
            if (!isAspectApprox(s.width, s.height, num, den)) continue;
            int area = s.width * s.height;
            if (bestAny == null || area > bestAny.width * bestAny.height) bestAny = s;
            if (maxArea > 0 && area <= maxArea) {
                if (bestUnder == null || area > bestUnder.width * bestUnder.height) bestUnder = s;
            }
        }
        if (maxArea > 0 && bestUnder != null) return bestUnder;
        return bestAny;
    }
    @Override public void onCreate() {
        super.onCreate();

        Context app = getApplicationContext();

        PowerManager pm = (PowerManager) app.getSystemService(Context.POWER_SERVICE);
        cpuLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "StreamService:cpu");
        cpuLock.setReferenceCounted(false);
        cpuLock.acquire();

        WifiManager wm = (WifiManager) app.getSystemService(Context.WIFI_SERVICE);
        wifiLock = wm.createWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF, "StreamService:wifi");
        wifiLock.setReferenceCounted(false);
        wifiLock.acquire();

        startForegroundNotification();
        openCamera();
        startServer();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent != null) {
            if (intent.hasExtra("preset")) {
                int p = intent.getIntExtra("preset", preset);
                if (p >= PRESET_LOW_43 && p <= PRESET_VGA_43) {
                    preset = p;
                    Log.i(TAG, "Preset set from Intent: " + preset);
                }
            }
            if (intent.hasExtra("buffering")) {
                enableBuffering = intent.getBooleanExtra("buffering", true);
                Log.i(TAG, "Buffering set from Intent: " + enableBuffering);
            }
        }
        return START_NOT_STICKY;
    }



    @Override public void onTaskRemoved(Intent rootIntent) {
        stopServer();
        closeCamera();
        stopForeground(true);
        releaseLocks();
        stopSelf();
        super.onTaskRemoved(rootIntent);
    }

    @Override public void onDestroy() {
        stopServer();
        closeCamera();
        stopForeground(true);
        releaseLocks();
        super.onDestroy();
    }

    @Override public IBinder onBind(Intent intent) { return null; }

    private void startForegroundNotification() {
        // No channels when compiling with API 19
        android.app.Notification n = new android.app.Notification.Builder(this)
                .setSmallIcon(android.R.drawable.presence_video_online)
                .setContentTitle("Glass streaming")
                .setContentText("Serving MJPEG on :8080/stream.mjpeg")
                .build();
        startForeground(NOTIF_ID, n);
    }



    // ---------- Camera ----------

    private void openCamera() {
        try {
            camera = Camera.open(); // back camera by default
            final Camera.Parameters params = camera.getParameters();

            // Optional: log supported sizes
            for (Camera.Size s : params.getSupportedPreviewSizes()) {
                Log.i(TAG, "Supported preview size: " + s.width + "x" + s.height);
            }

            // Areas for half-area logic
            final int AREA_1080P = 1080 * 1920;            // 2,073,600
            final int HALF_1080P = AREA_1080P / 2;         // 1,036,800
            final int AREA_1008x1346 = 1008 * 1346;        // 1,356,768
            final int HALF_1008x1346 = AREA_1008x1346 / 2; //   678,384

            Camera.Size chosen = null;
            switch (preset) {
                case PRESET_HIGH_169:
                    // 1080x1920 exact or closest
                    chosen = pickExactOrClosest(params, 1080, 1920);
                    break;
                case PRESET_LOW_169:
                    // largest 16:9 with area <= half of 1080p (typically 720x1280)
                    chosen = largestAspectUnderArea(params, 16, 9, HALF_1080P);
                    if (chosen == null) chosen = pickExactOrClosest(params, 720, 1280);
                    break;
                case PRESET_HIGH_43:
                    // 1008x1346 exact or closest
                    chosen = pickExactOrClosest(params, 1008, 1346);
                    break;
                case PRESET_LOW_43:
                    // largest 4:3 with area <= half of ~1.3MP 4:3 (typically 480x640)
                    chosen = largestAspectUnderArea(params, 4, 3, HALF_1008x1346);
                    if (chosen == null) chosen = pickExactOrClosest(params, 480, 640);
                    break;
                case PRESET_VGA_43:
                default:
                    chosen = pickExactOrClosest(params, 640, 480);
                    break;
            }

            if (chosen == null) {
                // Fallback: keep current HAL default
                chosen = params.getPreviewSize();
            }

            previewW = chosen.width;
            previewH = chosen.height;

            // Apply params
            params.setPreviewSize(previewW, previewH);
            params.setPreviewFormat(ImageFormat.NV21);
            // params.setRecordingHint(true); // optional, test on/off
            camera.setParameters(params);

            // Read back what HAL accepted (source of truth)
            Camera.Parameters confirmedParams = camera.getParameters();
            Camera.Size confirmed = confirmedParams.getPreviewSize();
            previewW = confirmed.width;
            previewH = confirmed.height;
            Log.i(TAG, "Preview confirmed by HAL: " + previewW + "x" + previewH);

            // Preview target
            surfaceTexture = new SurfaceTexture(0);
            surfaceTexture.setDefaultBufferSize(previewW, previewH);
            camera.setPreviewTexture(surfaceTexture);

            // Callback with buffers
            int bitsPerPixel = ImageFormat.getBitsPerPixel(ImageFormat.NV21);
            final int bufSize = previewW * previewH * bitsPerPixel / 2;
            for (int i = 0; i < 2; i++) camera.addCallbackBuffer(new byte[bufSize]);

            // Initialize write buffer once (safe if null)
            frameWrite = new byte[bufSize];

            camera.setPreviewCallbackWithBuffer(new Camera.PreviewCallback() {
                @Override public void onPreviewFrame(byte[] data, Camera cam) {
                    synchronized (frameLock) {
                        if (enableBuffering) {
                            // Double-buffer path (tear-free)
                            if (frameWrite == null || frameWrite.length != data.length) {
                                frameWrite = new byte[data.length];
                            }
                            System.arraycopy(data, 0, frameWrite, 0, data.length);
                            // publish atomically under the lock
                            frameReady = frameWrite;
                        } else {
                            // Single-buffer path (may tear under load)
                            if (lastFrameNV21 == null || lastFrameNV21.length != data.length) {
                                lastFrameNV21 = new byte[data.length];
                            }
                            System.arraycopy(data, 0, lastFrameNV21, 0, data.length);
                        }

                        frameCount++;
                        if ((frameCount % 30) == 0) {
                            Log.i(TAG, "Captured frames: " + frameCount + "  (" + previewW + "x" + previewH + ")");
                        }
                        frameLock.notifyAll();
                    }

                    if (cam != null) cam.addCallbackBuffer(data);
                }
            });

            camera.startPreview();
            Log.i(TAG, "Camera preview started at " + previewW + "x" + previewH);
        } catch (Exception e) {
            Log.e(TAG, "openCamera failed", e);
            stopSelf();
        }
    }

    private void closeCamera() {
        try {
            if (camera != null) {
                try { camera.setPreviewCallbackWithBuffer(null); } catch (Exception ignored) {}
                try { camera.setPreviewCallback(null); } catch (Exception ignored) {}
                try { camera.stopPreview(); } catch (Exception ignored) {}
                try { camera.release(); } catch (Exception ignored) {}
            }
        } catch (Exception ignored) {}
        camera = null;

        if (surfaceTexture != null) {
            try { surfaceTexture.release(); } catch (Exception ignored) {}
            surfaceTexture = null;
        }
    }

    // ---------- MJPEG ----------

    private byte[] currentJpeg() {
        byte[] src;
        int w, h;

        // Snapshot under lock
        synchronized (frameLock) {
            if (enableBuffering) {
                if (frameReady == null) return null;
                if (snapBuffer == null || snapBuffer.length != frameReady.length) {
                    snapBuffer = new byte[frameReady.length];
                }
                System.arraycopy(frameReady, 0, snapBuffer, 0, frameReady.length);
                src = snapBuffer;
            } else {
                if (lastFrameNV21 == null) return null;
                src = lastFrameNV21;
            }
            w = previewW;
            h = previewH;
        }

        try {
            // If you need sensor-based rotation, transform 'src' here and swap outW/outH accordingly.
            YuvImage yuv = new YuvImage(src, ImageFormat.NV21, w, h, null);
            ByteArrayOutputStream baos = jpgPool.get();
            baos.reset();
            // JPEG quality: 60 is a good balance; adjust to 55–65 to taste
            yuv.compressToJpeg(new Rect(0, 0, w, h), 60, baos);
            return baos.toByteArray();
        } catch (Exception e) {
            Log.w(TAG, "JPEG encode failed", e);
            return null;
        }
    }

    private void startServer() {
        running = true;
        pool = Executors.newCachedThreadPool();
        pool.execute(new Runnable() {
            @Override public void run() {
                try {
                    serverSocket = new ServerSocket(PORT);
                    Log.i(TAG, "Server listening on " + PORT);
                    while (running) {
                        Socket s = serverSocket.accept();
                        pool.execute(new ClientHandler(s));
                    }
                } catch (IOException e) {
                    Log.e(TAG, "Server error", e);
                }
            }
        });
    }

    private void stopServer() {
        running = false;
        try { if (serverSocket != null) serverSocket.close(); } catch (Exception ignored) {}
        if (pool != null) pool.shutdownNow();
    }

    private class ClientHandler implements Runnable {
        private final Socket socket;
        ClientHandler(Socket s) { socket = s; }

        @Override public void run() {
            try {
                socket.setTcpNoDelay(true);
                OutputStream raw = new BufferedOutputStream(socket.getOutputStream());

                String headers =
                        "HTTP/1.0 200 OK\r\n" +
                                "Connection: keep-alive\r\n" +
                                "Cache-Control: no-cache, private\r\n" +
                                "Pragma: no-cache\r\n" +
                                "Content-Type: multipart/x-mixed-replace; boundary=frame\r\n\r\n";
                raw.write(headers.getBytes("US-ASCII"));
                raw.flush();

                while (running && !socket.isClosed()) {
                    byte[] jpg = currentJpeg();
                    if (jpg == null) {
                        try { Thread.sleep(5); } catch (InterruptedException ignored) {}
                        continue;
                    }

                    String partHead =
                            "--frame\r\n" +
                                    "Content-Type: image/jpeg\r\n" +
                                    "Content-Length: " + jpg.length + "\r\n\r\n";
                    raw.write(partHead.getBytes("US-ASCII"));
                    raw.write(jpg);
                    raw.write("\r\n".getBytes("US-ASCII"));
                    raw.flush();

                    // Pace around 30 fps; this is gentler than forcing a hard preview fps.
                    try { Thread.sleep(33); } catch (InterruptedException ignored) {}
                }

            } catch (Exception e) {
                // client disconnects are expected; keep quiet
            } finally {
                try { socket.close(); } catch (Exception ignored) {}
            }
        }
    }
}
